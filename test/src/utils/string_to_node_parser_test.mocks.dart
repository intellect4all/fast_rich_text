// Mocks generated by Mockito 5.2.0 from annotations
// in flutter_rich_text/test/src/utils/string_to_node_parser_test.dart.
// Do not manually edit this file.

import 'package:flutter_rich_text/src/models/parsed_node.dart' as _i2;
import 'package:flutter_rich_text/src/models/special_symbol.dart' as _i3;
import 'package:flutter_rich_text/src/utils/string_to_node_parser.dart' as _i4;
import 'package:mockito/mockito.dart' as _i1;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types

class _FakeParsedNode_0 extends _i1.Fake implements _i2.ParsedNode {}

/// A class which mocks [SpecialSymbol].
///
/// See the documentation for Mockito's code generation for more information.
class MockSpecialSymbol extends _i1.Mock implements _i3.SpecialSymbol {
  MockSpecialSymbol() {
    _i1.throwOnMissingStub(this);
  }

  @override
  String get symbolChar =>
      (super.noSuchMethod(Invocation.getter(#symbol), returnValue: '')
          as String);
  @override
  List<int> get indexes =>
      (super.noSuchMethod(Invocation.getter(#indexes), returnValue: <int>[])
          as List<int>);
  @override
  List<int> get allIndexes =>
      (super.noSuchMethod(Invocation.getter(#allIndexes), returnValue: <int>[])
          as List<int>);
  @override
  List<Object?> get props =>
      (super.noSuchMethod(Invocation.getter(#props), returnValue: <Object?>[])
          as List<Object?>);
  @override
  int charIndexInSymbolList(int? pointer) =>
      (super.noSuchMethod(Invocation.method(#charIndexInSymbolList, [pointer]),
          returnValue: 0) as int);
  @override
  bool isSymbol(int? charIndex) =>
      (super.noSuchMethod(Invocation.method(#isSymbol, [charIndex]),
          returnValue: false) as bool);
  @override
  int getPointerIndexAfterSymbolMatchedPair(int? pointer) =>
      (super.noSuchMethod(
          Invocation.method(#getPointerIndexAfterSymbolMatchedPair, [pointer]),
          returnValue: 0) as int);
  @override
  int getPointerIndexBeforeSymbolMatchedPair(int? pointer) =>
      (super.noSuchMethod(
          Invocation.method(#getPointerIndexBeforeSymbolMatchedPair, [pointer]),
          returnValue: 0) as int);
  @override
  int nextSymbolIndex(dynamic pointer) =>
      (super.noSuchMethod(Invocation.method(#nextSymbolIndex, [pointer]),
          returnValue: 0) as int);
  @override
  bool isOutOfBound(dynamic pointer, {int? startIndex, int? endIndex}) =>
      (super.noSuchMethod(
          Invocation.method(#isOutOfBound, [pointer],
              {#startIndex: startIndex, #endIndex: endIndex}),
          returnValue: false) as bool);
  @override
  _i2.ParsedNode parse(int? currentIndexPointer,
          {List<_i3.SpecialSymbol>? symbolsToBeChecked = const [],
          _i4.StringToNodeParser? parser}) =>
      (super.noSuchMethod(
          Invocation.method(#parse, [currentIndexPointer],
              {#symbolsToBeChecked: symbolsToBeChecked, #parser: parser}),
          returnValue: _FakeParsedNode_0()) as _i2.ParsedNode);
}
